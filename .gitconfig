[user]
    name = toejough
    email = toejough@gmail.com

[core]
    ignoresFile = /Users/joe/.gitignore
    excludesFile = /Users/joe/.gitignore
    editor = vim

[credential]
    helper = osxkeychain

[merge]
    tool = vimdiff
    conflictstyle = diff3

[alias]
    # [ data ]
    name = rev-parse --abbrev-ref HEAD
    last-common-commit = merge-base HEAD
    has-local-changes-from = "!f() { if ( git fetch && git diff --quiet $(git last-common-commit $1) ); then test; fi }; f"
    has-changes-from-branch = "!git has-local-changes-from origin/$(git name)"
    has-changes-from-master = "!git has-local-changes-from origin/master"
    branches = branch -a
    tags = tag
    stashes = stash list
    graph = log --graph --branches --remotes --tags --topo-order --oneline --decorate
    raw-upstream = "!git for-each-ref --format='%(upstream:short)' $(git symbolic-ref -q HEAD)"
    upstream = "![[ -n $(git raw-upstream) ]] || ( echo 'no upstream branch set.' && test ) && git raw-upstream"

    # [ branch actions ]
    rename = "!f() { \
        printf '[*] identifying branch...'; \
        local NAME=\"$(git name)\"; \
        echo 'branch is:' \"$NAME\"; \
        echo '[*] renaming local branch to:' \"$1\"; \
        git branch -m \"$1\" && \
            echo '[*] pushing newly renamed branch to remote' && \
            git push origin --set-upstream \"$1\" && \
            echo '[*] removing old remote branch' && \
            git push origin :\"$NAME\"; \
    }; f"
    prune-dead-branches = "!git checkout master && git fetch && git re-tag-from origin/master && git rebase-branch-onto origin/master && git worktree prune && git remote prune origin; git branch --merged | egrep -v '^\\s*master$|^\\s*\\*.*' | xargs -L1 git branch -d && git branch -vv | ack ': gone' | awk '{print $1}' | xargs -L1 git branch -D"
    cleanup-from = "!f() { if git has-local-changes-from $1; then git rebase -i $(git last-common-commit $1); else echo 'Same as last common commit with '$1; fi }; f"

    # [ re-tagging actions ]
    re-tag-from = "!f() { \
        local LOCAL_TAG=\"local-base.$(git name)\"; \
        local BRANCH_TAG=\"branch-base.$(git name)\"; \
        local CURRENT_BRANCH=\"$(git name)\"; \
        local BRANCHED_FROM=\"${1}\"; \
        local BRANCH_START=\"$(git last-common-commit ${BRANCHED_FROM})\"; \
        local LOCAL_START=\"$(git last-common-commit origin/${CURRENT_BRANCH})\"; \
        git tag -f \"${LOCAL_TAG}\" \"${LOCAL_START}\"; \
        git tag -f \"${BRANCH_TAG}\" \"${BRANCH_START}\"; \
    }; f"

    # [ file state actions ]
    # unstage a staged file
    unstage = reset HEAD --
    # discard a file's changes
    discard = checkout --
    # undo last commit
    uncommit = reset --soft HEAD~
    # remove all local state
    nuke-local-state = "!git reset --hard origin/$(git name) && git clean -xdff"

    # [ workflow actions ]
    # Get a true representation of the remote master, locally
    update-master = "!git checkout master && git fetch && git reset --hard origin/master"
    # Create a new branch from where-ever you are now.
    #   Also tags this as your branch's base point for easier rebasing later.
    #     This tag will get pushed to your remote branch for branch history tracking.
    #   Also tags this as your local commit history start for easier rebasing later.
    #     This tag will *not* get pushed to your remote branch - it's for local history tracking _only_.
    new-branch = "!f() { \
        git checkout -b $1; \
        git tag \"branch-base.$1\"; \
        git push --set-upstream origin $(git name); \
        git push --tags; \
        git tag \"local-base.$1\"; \
    }; f"
    # clean your local commits up before pushing to the remote
    clean-local = "!f() { \
        local START=\"local-base.$(git name)\"; \
        local STOP=\"$(git name)\"; \
        local ONTO=\"${START}\"; \
        git rebase -i --onto \"${ONTO}\" \"${START}\" \"${STOP}\"; \
    }; f"
    # rebase your branch from the local base point onto the given commit/branch/tag
    #   This may or may not be the origin version of this branch (git fetch; git rebase-local-onto origin/<branch>)
    rebase-local-onto = "!f() { \
        local START=\"local-base.$(git name)\"; \
        local STOP=\"$(git name)\"; \
        local ONTO=\"${1}\"; \
        git rebase --onto \"${ONTO}\" \"${START}\" \"${STOP}\" || return 1; \
        git tag -f \"${START}\" \"${ONTO}\"; \
    }; f"
    # clean your branch's commits up before merging to another branch
    clean-branch = "!f() { \
        local START=\"branch-base.$(git name)\"; \
        local STOP=\"$(git name)\"; \
        local ONTO=\"${START}\"; \
        git rebase -i --onto \"${ONTO}\" \"${START}\" \"${STOP}\" || return 1; \
        local LOCAL=\"local-base.$(git name)\"; \
        git tag -f \"${LOCAL}\" \"${ONTO}\"; \
    }; f"
    # rebase your branch from the branch base point onto the given commit/branch/tag
    rebase-branch-onto = "!f() { \
        local START=\"branch-base.$(git name)\"; \
        local STOP=\"$(git name)\"; \
        local ONTO=\"${1}\"; \
        git rebase --onto \"${ONTO}\" \"${START}\" \"${STOP}\" || return 1; \
        local LOCAL=\"local-base.$(git name)\"; \
        git tag -f \"${LOCAL}\" \"${ONTO}\" && \
        git tag -f \"${START}\" \"${ONTO}\"; \
    }; f"
    # push your branch to the remote
    push-branch = "!f() { \
        local BRANCH=\"$(git name)\"; \
        local ONTO=\"${1}\"; \
        git push -f || return 1; \
        local LOCAL=\"local-base.$(git name)\"; \
        git tag --delete \"${LOCAL}\"; \
        git push -f --tags; \
        git tag -f \"${LOCAL}\" \"${BRANCH}\"; \
    }; f"

    # [ Force-push recovery ]
    recover-last-remote = "!git checkout -b recover.$(git name) && git reset --hard refs/remotes/origin/$(git name)@{1}; echo 'triple check this is the branch state you want, and then switch back to your branch, run git use-recovery-version and git integrate-master again."
    use-recovery-version = "!git reset --hard recover.$(git name); echo 'if you are really sure, git integrate-master.'"

    # [ Worktree ]
    workon-new = "!f() { local location=$(echo $1 | tr . -); git worktree add -b $1 ../$location $(git name); cd ../$location; git push -u origin $1; echo \"set up branch $1 at ../$location\"; }; f"
    workon-local = "!f() { local location=$(echo $1 | tr . -); git worktree add ../$location $1; cd ../$location; git push -u origin $1; echo \"set up branch $1 at ../$location\"; }; f"
    workon-remote = "!f() { local location=$(echo $1 | tr . -); git worktree add ../$location $1; echo \"set up branch $1 at ../$location\"; }; f"
    parent = "!git rev-parse --git-dir | awk -F/ '{ print $(NF-3)  }'"

[push]
    default = simple
    followTags = true

[commit]
    template = /Users/joe/.settings/git-commit-template.txt

[help]
    autocorrect = 20

[pull]
    ff = only
    rebase = preserve

[remote.origin]
    tagOpt = --tags

[rebase]
    autosquash = true

[fetch]
    prune = true

[diff]
    compactionHeuristic = true

; https://github.com/so-fancy/diff-so-fancy/issues/296
;[pager]
;    log = "diff-so-fancy | less --tabs=4 -RFX"
;    show = "diff-so-fancy | less --tabs=4 -RFX"
;    diff = "diff-so-fancy | less --tabs=4 -RFX"

;[interactive]
;    diffFilter = "diff-so-fancy | less --tabs=4 -RFX"
